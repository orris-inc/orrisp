// AUTO-GENERATED - DO NOT EDIT
// Generated by Claude from orris backend
// Source: github.com/orris-inc/orris/sdk/agent

package api

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"sync"
	"time"

	"github.com/gorilla/websocket"
)

// Hub message type constants.
const (
	// Agent -> Server message types.
	MsgTypeStatus    = "status"
	MsgTypeHeartbeat = "heartbeat"
	MsgTypeEvent     = "event"

	// Server -> Agent message types.
	MsgTypeCommand    = "command"
	MsgTypeConfigSync = "config_sync"
)

// Command action constants.
const (
	CmdActionReloadConfig = "reload_config"
	CmdActionRestart      = "restart"
	CmdActionStop         = "stop"
)

// Event type constants.
const (
	EventTypeConnected    = "connected"
	EventTypeDisconnected = "disconnected"
	EventTypeError        = "error"
	EventTypeConfigChange = "config_change"
)

// HubMessage is the unified WebSocket message envelope.
type HubMessage struct {
	Type      string `json:"type"`
	NodeID    string `json:"node_id,omitempty"` // Stripe-style prefixed ID (e.g., "node_xK9mP2vL3nQ")
	Timestamp int64  `json:"timestamp"`
	Data      any    `json:"data,omitempty"`
}

// CommandData represents a command from server.
type CommandData struct {
	CommandID string `json:"command_id"`
	Action    string `json:"action"`
	Payload   any    `json:"payload,omitempty"`
}

// EventData represents an event to send to server.
type EventData struct {
	EventType string `json:"event_type"`
	Message   string `json:"message,omitempty"`
	Extra     any    `json:"extra,omitempty"`
}

// ConfigSyncData represents configuration sync from server.
type ConfigSyncData struct {
	Version   uint64      `json:"version"`
	FullSync  bool        `json:"full_sync"`
	Config    *ConfigData `json:"config,omitempty"`
	Timestamp int64       `json:"timestamp"`
}

// ConfigData represents the node configuration for hub sync.
type ConfigData struct {
	NodeSID           string       `json:"node_id"`
	Protocol          string       `json:"protocol"`
	ServerHost        string       `json:"server_host"`
	ServerPort        int          `json:"server_port"`
	EncryptionMethod  string       `json:"encryption_method,omitempty"`
	ServerKey         string       `json:"server_key,omitempty"`
	TransportProtocol string       `json:"transport_protocol"`
	Host              string       `json:"host,omitempty"`
	Path              string       `json:"path,omitempty"`
	ServiceName       string       `json:"service_name,omitempty"`
	SNI               string       `json:"sni,omitempty"`
	AllowInsecure     bool         `json:"allow_insecure"`
	Route             *RouteConfig `json:"route,omitempty"`     // Routing configuration for traffic splitting
	Outbounds         []Outbound   `json:"outbounds,omitempty"` // Outbound configs for nodes referenced in route rules
}

// Hub errors.
var (
	ErrHubNotConnected = errors.New("hub: not connected")
	ErrHubClosed       = errors.New("hub: connection closed")
	ErrHubInsecureURL  = errors.New("hub: WebSocket URL must use WSS to protect sensitive data")
)

// HubHandler handles incoming hub messages.
type HubHandler interface {
	// OnCommand is called when a command is received from the server.
	OnCommand(cmd *CommandData)
	// OnConfigSync is called when a config sync message is received.
	OnConfigSync(sync *ConfigSyncData)
	// OnError is called when an error occurs.
	OnError(err error)
	// OnDisconnect is called when the connection is closed.
	OnDisconnect()
}

// HubClient manages the WebSocket connection to the hub.
type HubClient struct {
	baseURL string
	token   string
	nodeSID string

	conn    *websocket.Conn
	handler HubHandler

	sendCh chan []byte
	done   chan struct{}
	mu     sync.RWMutex

	// Connection settings
	pingInterval time.Duration
	pongWait     time.Duration
	writeWait    time.Duration
}

// HubOption is a function that configures the HubClient.
type HubOption func(*HubClient)

// WithPingInterval sets the ping interval.
func WithPingInterval(d time.Duration) HubOption {
	return func(h *HubClient) {
		h.pingInterval = d
	}
}

// WithPongWait sets the pong wait timeout.
func WithPongWait(d time.Duration) HubOption {
	return func(h *HubClient) {
		h.pongWait = d
	}
}

// NewHubClient creates a new hub client.
//
// Parameters:
//   - baseURL: The WebSocket base URL (must use WSS, e.g., "wss://api.example.com")
//   - token: The node authentication token
//   - nodeSID: The node SID assigned by the server (Stripe-style: node_xxx)
//   - handler: The handler for incoming messages
//
// Returns an error if the base URL does not use WSS/HTTPS.
func NewHubClient(baseURL, token, nodeSID string, handler HubHandler, opts ...HubOption) (*HubClient, error) {
	// Validate that the base URL uses secure scheme
	if err := validateSecureHubURL(baseURL); err != nil {
		return nil, err
	}

	h := &HubClient{
		baseURL:      baseURL,
		token:        token,
		nodeSID:      nodeSID,
		handler:      handler,
		sendCh:       make(chan []byte, 256),
		done:         make(chan struct{}),
		pingInterval: 30 * time.Second,
		pongWait:     60 * time.Second,
		writeWait:    10 * time.Second,
	}
	for _, opt := range opts {
		opt(h)
	}
	return h, nil
}

// validateSecureHubURL validates that the URL uses WSS or HTTPS scheme.
// WS/HTTP is allowed for IP addresses and localhost (development/internal use).
func validateSecureHubURL(rawURL string) error {
	parsed, err := url.Parse(rawURL)
	if err != nil {
		return fmt.Errorf("invalid URL: %w", err)
	}

	scheme := parsed.Scheme
	if scheme == "wss" || scheme == "https" {
		return nil
	}

	// Allow insecure for IP addresses and localhost
	host := parsed.Hostname()
	if isIPAddress(host) || isLocalhost(host) {
		return nil
	}

	return ErrHubInsecureURL
}

// Connect establishes the WebSocket connection.
func (h *HubClient) Connect() error {
	h.mu.Lock()

	if h.conn != nil {
		h.mu.Unlock()
		return nil // Already connected
	}

	// Build WebSocket URL
	u, err := url.Parse(h.baseURL)
	if err != nil {
		h.mu.Unlock()
		return fmt.Errorf("parse base url: %w", err)
	}

	// Convert http(s) to ws(s)
	switch u.Scheme {
	case "https":
		u.Scheme = "wss"
	case "http":
		u.Scheme = "ws"
	}

	// Preserve base path prefix (e.g., /v1) and append WebSocket endpoint
	u.Path = path.Join(u.Path, "ws/node-agent")
	q := u.Query()
	q.Set("token", h.token)
	u.RawQuery = q.Encode()

	// Connect with headers
	header := http.Header{}
	header.Set("X-Node-Token", h.token)

	conn, _, err := websocket.DefaultDialer.Dial(u.String(), header)
	if err != nil {
		h.mu.Unlock()
		return fmt.Errorf("dial websocket: %w", err)
	}

	h.conn = conn
	h.done = make(chan struct{})
	h.sendCh = make(chan []byte, 256)

	// Start read and write pumps with conn passed as parameter to avoid race
	go h.readPump(conn)
	go h.writePump(conn)

	// Release lock before sendEvent to avoid deadlock
	// (sendMessage acquires RLock, can't acquire while holding Lock)
	h.mu.Unlock()

	// Send connected event
	h.sendEvent(EventTypeConnected, "connected to hub", nil)

	return nil
}

// Close closes the WebSocket connection.
func (h *HubClient) Close() error {
	h.mu.Lock()
	defer h.mu.Unlock()

	if h.conn == nil {
		return nil
	}

	close(h.done)
	err := h.conn.Close()
	h.conn = nil
	return err
}

// SendStatus sends a status update to the server.
func (h *HubClient) SendStatus(status *NodeStatus) error {
	return h.sendMessage(MsgTypeStatus, status)
}

// SendHeartbeat sends a heartbeat to the server.
func (h *HubClient) SendHeartbeat() error {
	return h.sendMessage(MsgTypeHeartbeat, nil)
}

// SendEvent sends an event to the server.
func (h *HubClient) SendEvent(eventType, message string, extra any) error {
	return h.sendEvent(eventType, message, extra)
}

func (h *HubClient) sendEvent(eventType, message string, extra any) error {
	event := &EventData{
		EventType: eventType,
		Message:   message,
		Extra:     extra,
	}
	return h.sendMessage(MsgTypeEvent, event)
}

func (h *HubClient) sendMessage(msgType string, data any) error {
	h.mu.RLock()
	conn := h.conn
	h.mu.RUnlock()

	if conn == nil {
		return ErrHubNotConnected
	}

	msg := HubMessage{
		Type:      msgType,
		NodeID:    h.nodeSID,
		Timestamp: time.Now().Unix(),
		Data:      data,
	}

	msgBytes, err := json.Marshal(msg)
	if err != nil {
		return fmt.Errorf("marshal message: %w", err)
	}

	select {
	case h.sendCh <- msgBytes:
		return nil
	case <-h.done:
		return ErrHubClosed
	default:
		return fmt.Errorf("send buffer full")
	}
}

func (h *HubClient) readPump(conn *websocket.Conn) {
	defer func() {
		h.handler.OnDisconnect()
		h.mu.Lock()
		if h.conn != nil {
			h.conn.Close()
			h.conn = nil
		}
		h.mu.Unlock()
	}()

	conn.SetReadLimit(65536)
	conn.SetReadDeadline(time.Now().Add(h.pongWait))
	conn.SetPongHandler(func(string) error {
		conn.SetReadDeadline(time.Now().Add(h.pongWait))
		return nil
	})

	for {
		_, message, err := conn.ReadMessage()
		if err != nil {
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				h.handler.OnError(fmt.Errorf("read error: %w", err))
			}
			return
		}

		var msg HubMessage
		if err := json.Unmarshal(message, &msg); err != nil {
			h.handler.OnError(fmt.Errorf("unmarshal message: %w", err))
			continue
		}

		h.handleMessage(&msg)
	}
}

func (h *HubClient) writePump(conn *websocket.Conn) {
	ticker := time.NewTicker(h.pingInterval)
	defer ticker.Stop()

	for {
		select {
		case msg := <-h.sendCh:
			conn.SetWriteDeadline(time.Now().Add(h.writeWait))
			if err := conn.WriteMessage(websocket.TextMessage, msg); err != nil {
				h.handler.OnError(fmt.Errorf("write error: %w", err))
				return
			}

		case <-ticker.C:
			conn.SetWriteDeadline(time.Now().Add(h.writeWait))
			if err := conn.WriteMessage(websocket.PingMessage, nil); err != nil {
				return
			}

		case <-h.done:
			return
		}
	}
}

func (h *HubClient) handleMessage(msg *HubMessage) {
	switch msg.Type {
	case MsgTypeCommand:
		h.handleCommand(msg.Data)
	case MsgTypeConfigSync:
		h.handleConfigSync(msg.Data)
	}
}

func (h *HubClient) handleCommand(data any) {
	dataBytes, err := json.Marshal(data)
	if err != nil {
		h.handler.OnError(fmt.Errorf("marshal command data: %w", err))
		return
	}

	var cmd CommandData
	if err := json.Unmarshal(dataBytes, &cmd); err != nil {
		h.handler.OnError(fmt.Errorf("unmarshal command: %w", err))
		return
	}

	h.handler.OnCommand(&cmd)
}

func (h *HubClient) handleConfigSync(data any) {
	dataBytes, err := json.Marshal(data)
	if err != nil {
		h.handler.OnError(fmt.Errorf("marshal config sync data: %w", err))
		return
	}

	var sync ConfigSyncData
	if err := json.Unmarshal(dataBytes, &sync); err != nil {
		h.handler.OnError(fmt.Errorf("unmarshal config sync: %w", err))
		return
	}

	h.handler.OnConfigSync(&sync)
}
