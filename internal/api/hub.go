// AUTO-GENERATED - DO NOT EDIT
// Generated by Claude from orris backend
// Source: github.com/orris-inc/orris/sdk/agent

package api

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"sync"
	"time"

	"github.com/gorilla/websocket"
)

// Hub message type constants define all WebSocket message types exchanged between node agent and server.
//
// Message Flow:
//
//	Agent -> Server:
//	  - status:    Node status report (CPU, memory, network, connections, etc.)
//	  - heartbeat: Keep-alive heartbeat
//	  - event:     Node events (connected, disconnected, error, config_change)
//
//	Server -> Agent:
//	  - command:           Server commands (reload_config, restart, stop, update)
//	  - config_sync:       Configuration sync (full or incremental)
//	  - subscription_sync: Subscription changes (added, updated, removed)
const (
	// Agent -> Server message types.
	MsgTypeStatus    = "status"    // Send node status (NodeStatus)
	MsgTypeHeartbeat = "heartbeat" // Send heartbeat to keep connection alive
	MsgTypeEvent     = "event"     // Send node events (EventData)

	// Server -> Agent message types.
	MsgTypeCommand          = "command"           // Receive server commands (CommandData)
	MsgTypeConfigSync       = "config_sync"       // Receive config sync (ConfigSyncData)
	MsgTypeSubscriptionSync = "subscription_sync" // Receive subscription changes (SubscriptionSyncData)

	// Tunnel health report message types (Agent reports exit agent health status).
	MsgTypeTunnelHealthReport = "tunnel_health_report" // Agent -> Server
)

// Command action constants define available server commands.
//
// Supported Actions:
//   - reload_config:   Trigger node to reload configuration from server
//   - restart:         Restart the node agent
//   - stop:            Stop the node agent
//   - update:          Update node agent binary to new version
//   - api_url_changed: API URL changed, node should reconnect to new URL
const (
	CmdActionReloadConfig   = "reload_config"   // Reload configuration
	CmdActionRestart        = "restart"         // Restart node agent
	CmdActionStop           = "stop"            // Stop node agent
	CmdActionUpdate         = "update"          // Update agent binary
	CmdActionAPIURLChanged  = "api_url_changed" // API URL changed, reconnect to new URL
	CmdActionConfigRelocate = "config_relocate" // Configuration relocated to new server
)

// APIURLChangedPayload contains the new API URL for node reconnection.
// This is the payload structure when CommandData.Action == CmdActionAPIURLChanged.
type APIURLChangedPayload struct {
	NewURL string `json:"new_url"` // New API base URL to connect to
	Reason string `json:"reason"`  // Reason for the change (e.g., "server migration")
}

// Event type constants define events that node agent can report to server.
//
// Supported Events:
//   - connected:     Node successfully connected to hub
//   - disconnected:  Node disconnected from hub
//   - error:         Node encountered an error (Message contains error details)
//   - config_change: Node configuration changed (Extra may contain change details)
//   - traffic:       Traffic data update (Extra contains []TrafficReport)
const (
	EventTypeConnected    = "connected"     // Node connected
	EventTypeDisconnected = "disconnected"  // Node disconnected
	EventTypeError        = "error"         // Error occurred
	EventTypeConfigChange = "config_change" // Configuration changed
	EventTypeTraffic      = "traffic"       // Traffic data update
)

// HubMessage is the unified WebSocket message envelope.
// Used for all communication between node agent and server.
type HubMessage struct {
	Type      string `json:"type"`              // Message type (see MsgType* constants)
	NodeID    string `json:"node_id,omitempty"` // Stripe-style prefixed ID (e.g., "node_xK9mP2vL3nQ")
	Timestamp int64  `json:"timestamp"`         // Unix timestamp
	Data      any    `json:"data,omitempty"`    // Message payload
}

// CommandData represents a command sent from server to node agent.
// Used with MsgTypeCommand message type.
type CommandData struct {
	CommandID string `json:"command_id"` // Unique command identifier
	Action    string `json:"action"`     // Command action (see CmdAction* constants)
	Payload   any    `json:"payload,omitempty"`
}

// EventData represents an event payload sent from node agent to server.
// Used with MsgTypeEvent message type via HubClient.SendEvent().
type EventData struct {
	EventType string `json:"event_type"`        // Event type (see EventType* constants)
	Message   string `json:"message,omitempty"` // Human-readable message
	Extra     any    `json:"extra,omitempty"`   // Additional event-specific data
}

// ConfigSyncData represents configuration sync data sent from server to node agent.
// Used with MsgTypeConfigSync message type.
// The handler receives this via HubHandler.OnConfigSync().
type ConfigSyncData struct {
	Version   uint64      `json:"version"`          // Configuration version number
	FullSync  bool        `json:"full_sync"`        // True if this is a full sync, false for incremental
	Config    *ConfigData `json:"config,omitempty"` // Node configuration
	Timestamp int64       `json:"timestamp"`        // Unix timestamp
}

// Subscription change type constants define the type of subscription change.
const (
	SubscriptionChangeAdded   = "added"   // New subscription added
	SubscriptionChangeUpdated = "updated" // Subscription updated (status, expiry, etc.)
	SubscriptionChangeRemoved = "removed" // Subscription removed or expired
)

// SubscriptionSyncData represents subscription sync data sent from server to node agent.
// Used with MsgTypeSubscriptionSync message type.
// The handler receives this via HubHandler.OnSubscriptionSync().
type SubscriptionSyncData struct {
	ChangeType    string         `json:"change_type"`             // Change type (added, updated, removed)
	Subscriptions []Subscription `json:"subscriptions,omitempty"` // Affected subscriptions
	Timestamp     int64          `json:"timestamp"`               // Unix timestamp
}

// TunnelHealthReport represents a tunnel health status report from entry agent.
// Entry agents periodically check tunnel connectivity to exit agents and report failures.
// Used with MsgTypeTunnelHealthReport message type.
type TunnelHealthReport struct {
	RuleID      string `json:"rule_id"`                // Rule ID (Stripe-style prefixed, e.g., "fr_xxx")
	ExitAgentID string `json:"exit_agent_id"`          // Exit agent ID (Stripe-style prefixed, e.g., "fa_xxx")
	Healthy     bool   `json:"healthy"`                // Whether the tunnel is healthy
	FailCount   int    `json:"fail_count,omitempty"`   // Consecutive failure count (when unhealthy)
	Error       string `json:"error,omitempty"`        // Error message (when unhealthy)
	LatencyMs   *int64 `json:"latency_ms,omitempty"`   // Last measured latency in milliseconds (when healthy)
	CheckedAt   int64  `json:"checked_at"`             // Health check timestamp (Unix seconds)
}

// ConfigData represents the node configuration for hub sync.
type ConfigData struct {
	NodeSID           string       `json:"node_id"`
	Protocol          string       `json:"protocol"`                    // Protocol type: shadowsocks, trojan, vless, vmess, hysteria2, tuic, anytls
	ServerHost        string       `json:"server_host"`
	ServerPort        int          `json:"server_port"`
	EncryptionMethod  string       `json:"encryption_method,omitempty"`
	ServerKey         string       `json:"server_key,omitempty"`
	TransportProtocol string       `json:"transport_protocol"`          // Transport protocol (tcp, ws, grpc, h2, http, quic)
	Host              string       `json:"host,omitempty"`
	Path              string       `json:"path,omitempty"`
	ServiceName       string       `json:"service_name,omitempty"`
	SNI               string       `json:"sni,omitempty"`
	AllowInsecure     bool         `json:"allow_insecure"`
	Route             *RouteConfig `json:"route,omitempty"`     // Routing configuration for traffic splitting
	DNS               *DnsConfig   `json:"dns,omitempty"`       // DNS configuration for DNS-based unlocking
	Outbounds         []Outbound   `json:"outbounds,omitempty"` // Outbound configs for nodes referenced in route rules

	// VLESS specific fields
	Flow        string `json:"flow,omitempty"`        // VLESS flow control (xtls-rprx-vision)
	Security    string `json:"security,omitempty"`    // Security type (none, tls, reality)
	Fingerprint string `json:"fingerprint,omitempty"` // TLS fingerprint
	PrivateKey  string `json:"private_key,omitempty"` // Reality private key
	PublicKey   string `json:"public_key,omitempty"`  // Reality public key
	ShortID     string `json:"short_id,omitempty"`    // Reality short ID
	SpiderX     string `json:"spider_x,omitempty"`    // Reality spider X

	// VMess specific fields
	AlterID int  `json:"alter_id,omitempty"` // VMess alter ID
	TLS     bool `json:"tls,omitempty"`      // Enable TLS (VMess)

	// Hysteria2 specific fields
	Password          string `json:"password,omitempty"`           // Hysteria2/TUIC password
	CongestionControl string `json:"congestion_control,omitempty"` // Congestion control algorithm
	Obfs              string `json:"obfs,omitempty"`               // Obfuscation type
	ObfsPassword      string `json:"obfs_password,omitempty"`      // Obfuscation password
	UpMbps            *int   `json:"up_mbps,omitempty"`            // Upstream bandwidth limit
	DownMbps          *int   `json:"down_mbps,omitempty"`          // Downstream bandwidth limit

	// TUIC specific fields
	UUID         string `json:"uuid,omitempty"`           // TUIC UUID
	UDPRelayMode string `json:"udp_relay_mode,omitempty"` // UDP relay mode (native, quic)
	ALPN         string `json:"alpn,omitempty"`           // ALPN protocols
	DisableSNI   bool   `json:"disable_sni,omitempty"`    // Disable SNI

	// AnyTLS specific fields
	AnyTLSFingerprint              string `json:"anytls_fingerprint,omitempty"`                // TLS fingerprint for AnyTLS
	AnyTLSIdleSessionCheckInterval string `json:"anytls_idle_session_check_interval,omitempty"` // Idle session check interval
	AnyTLSIdleSessionTimeout       string `json:"anytls_idle_session_timeout,omitempty"`        // Idle session timeout
	AnyTLSMinIdleSession           int    `json:"anytls_min_idle_session,omitempty"`             // Minimum idle sessions
}

// Hub errors.
var (
	ErrHubNotConnected = errors.New("hub: not connected")
	ErrHubClosed       = errors.New("hub: connection closed")
	ErrHubInsecureURL  = errors.New("hub: WebSocket URL must use WSS to protect sensitive data")
)

// HubHandler handles incoming hub messages.
type HubHandler interface {
	// OnCommand is called when a command is received from the server.
	OnCommand(cmd *CommandData)
	// OnConfigSync is called when a config sync message is received.
	OnConfigSync(sync *ConfigSyncData)
	// OnSubscriptionSync is called when a subscription sync message is received.
	// This notifies the agent about subscription changes (added, updated, removed).
	OnSubscriptionSync(sync *SubscriptionSyncData)
	// OnError is called when an error occurs.
	OnError(err error)
	// OnDisconnect is called when the connection is closed.
	OnDisconnect()
}

// HubClient manages the WebSocket connection to the hub.
type HubClient struct {
	baseURL string
	token   string
	nodeSID string

	conn    *websocket.Conn
	handler HubHandler

	sendCh chan []byte
	done   chan struct{}
	mu     sync.RWMutex

	// Connection settings
	pingInterval time.Duration
	pongWait     time.Duration
	writeWait    time.Duration
}

// HubOption is a function that configures the HubClient.
type HubOption func(*HubClient)

// WithPingInterval sets the ping interval.
func WithPingInterval(d time.Duration) HubOption {
	return func(h *HubClient) {
		h.pingInterval = d
	}
}

// WithPongWait sets the pong wait timeout.
func WithPongWait(d time.Duration) HubOption {
	return func(h *HubClient) {
		h.pongWait = d
	}
}

// NewHubClient creates a new hub client.
//
// Parameters:
//   - baseURL: The WebSocket base URL (must use WSS, e.g., "wss://api.example.com")
//   - token: The node authentication token
//   - nodeSID: The node SID assigned by the server (Stripe-style: node_xxx)
//   - handler: The handler for incoming messages
//
// Returns an error if the base URL does not use WSS/HTTPS.
func NewHubClient(baseURL, token, nodeSID string, handler HubHandler, opts ...HubOption) (*HubClient, error) {
	// Validate that the base URL uses secure scheme
	if err := validateSecureHubURL(baseURL); err != nil {
		return nil, err
	}

	h := &HubClient{
		baseURL:      baseURL,
		token:        token,
		nodeSID:      nodeSID,
		handler:      handler,
		sendCh:       make(chan []byte, 256),
		done:         make(chan struct{}),
		pingInterval: 30 * time.Second,
		pongWait:     60 * time.Second,
		writeWait:    10 * time.Second,
	}
	for _, opt := range opts {
		opt(h)
	}
	return h, nil
}

// validateSecureHubURL validates that the URL uses WSS or HTTPS scheme.
// WS/HTTP is allowed for IP addresses and localhost (development/internal use).
func validateSecureHubURL(rawURL string) error {
	parsed, err := url.Parse(rawURL)
	if err != nil {
		return fmt.Errorf("invalid URL: %w", err)
	}

	scheme := parsed.Scheme
	if scheme == "wss" || scheme == "https" {
		return nil
	}

	// Allow insecure for IP addresses and localhost
	host := parsed.Hostname()
	if isIPAddress(host) || isLocalhost(host) {
		return nil
	}

	return ErrHubInsecureURL
}

// Connect establishes the WebSocket connection.
func (h *HubClient) Connect() error {
	h.mu.Lock()

	if h.conn != nil {
		h.mu.Unlock()
		return nil // Already connected
	}

	// Build WebSocket URL
	u, err := url.Parse(h.baseURL)
	if err != nil {
		h.mu.Unlock()
		return fmt.Errorf("parse base url: %w", err)
	}

	// Convert http(s) to ws(s)
	switch u.Scheme {
	case "https":
		u.Scheme = "wss"
	case "http":
		u.Scheme = "ws"
	}

	// Preserve base path prefix (e.g., /v1) and append WebSocket endpoint
	u.Path = path.Join(u.Path, "ws/node-agent")
	q := u.Query()
	q.Set("token", h.token)
	u.RawQuery = q.Encode()

	// Connect with headers
	header := http.Header{}
	header.Set("X-Node-Token", h.token)

	conn, _, err := websocket.DefaultDialer.Dial(u.String(), header)
	if err != nil {
		h.mu.Unlock()
		return fmt.Errorf("dial websocket: %w", err)
	}

	h.conn = conn
	h.done = make(chan struct{})
	h.sendCh = make(chan []byte, 256)

	// Start read and write pumps with conn passed as parameter to avoid race
	go h.readPump(conn)
	go h.writePump(conn)

	// Release lock before sendEvent to avoid deadlock
	// (sendMessage acquires RLock, can't acquire while holding Lock)
	h.mu.Unlock()

	// Send connected event
	h.sendEvent(EventTypeConnected, "connected to hub", nil)

	return nil
}

// Close closes the WebSocket connection.
func (h *HubClient) Close() error {
	h.mu.Lock()
	defer h.mu.Unlock()

	if h.conn == nil {
		return nil
	}

	close(h.done)
	err := h.conn.Close()
	h.conn = nil
	return err
}

// SendStatus sends a status update to the server.
func (h *HubClient) SendStatus(status *NodeStatus) error {
	return h.sendMessage(MsgTypeStatus, status)
}

// SendHeartbeat sends a heartbeat to the server.
func (h *HubClient) SendHeartbeat() error {
	return h.sendMessage(MsgTypeHeartbeat, nil)
}

// SendEvent sends an event to the server.
func (h *HubClient) SendEvent(eventType, message string, extra any) error {
	return h.sendEvent(eventType, message, extra)
}

// SendTunnelHealthReport sends a tunnel health report to the server.
// Entry agents use this to report the health status of tunnels to exit agents.
func (h *HubClient) SendTunnelHealthReport(report *TunnelHealthReport) error {
	return h.sendMessage(MsgTypeTunnelHealthReport, report)
}

func (h *HubClient) sendEvent(eventType, message string, extra any) error {
	event := &EventData{
		EventType: eventType,
		Message:   message,
		Extra:     extra,
	}
	return h.sendMessage(MsgTypeEvent, event)
}

func (h *HubClient) sendMessage(msgType string, data any) error {
	h.mu.RLock()
	conn := h.conn
	h.mu.RUnlock()

	if conn == nil {
		return ErrHubNotConnected
	}

	msg := HubMessage{
		Type:      msgType,
		NodeID:    h.nodeSID,
		Timestamp: time.Now().Unix(),
		Data:      data,
	}

	msgBytes, err := json.Marshal(msg)
	if err != nil {
		return fmt.Errorf("marshal message: %w", err)
	}

	select {
	case h.sendCh <- msgBytes:
		return nil
	case <-h.done:
		return ErrHubClosed
	default:
		return fmt.Errorf("send buffer full")
	}
}

func (h *HubClient) readPump(conn *websocket.Conn) {
	defer func() {
		h.handler.OnDisconnect()
		h.mu.Lock()
		if h.conn != nil {
			h.conn.Close()
			h.conn = nil
		}
		h.mu.Unlock()
	}()

	conn.SetReadLimit(65536)
	conn.SetReadDeadline(time.Now().Add(h.pongWait))
	conn.SetPongHandler(func(string) error {
		conn.SetReadDeadline(time.Now().Add(h.pongWait))
		return nil
	})

	for {
		_, message, err := conn.ReadMessage()
		if err != nil {
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				h.handler.OnError(fmt.Errorf("read error: %w", err))
			}
			return
		}

		var msg HubMessage
		if err := json.Unmarshal(message, &msg); err != nil {
			h.handler.OnError(fmt.Errorf("unmarshal message: %w", err))
			continue
		}

		h.handleMessage(&msg)
	}
}

func (h *HubClient) writePump(conn *websocket.Conn) {
	ticker := time.NewTicker(h.pingInterval)
	defer ticker.Stop()

	for {
		select {
		case msg := <-h.sendCh:
			conn.SetWriteDeadline(time.Now().Add(h.writeWait))
			if err := conn.WriteMessage(websocket.TextMessage, msg); err != nil {
				h.handler.OnError(fmt.Errorf("write error: %w", err))
				return
			}

		case <-ticker.C:
			conn.SetWriteDeadline(time.Now().Add(h.writeWait))
			if err := conn.WriteMessage(websocket.PingMessage, nil); err != nil {
				return
			}

		case <-h.done:
			return
		}
	}
}

func (h *HubClient) handleMessage(msg *HubMessage) {
	switch msg.Type {
	case MsgTypeCommand:
		h.handleCommand(msg.Data)
	case MsgTypeConfigSync:
		h.handleConfigSync(msg.Data)
	case MsgTypeSubscriptionSync:
		h.handleSubscriptionSync(msg.Data)
	}
}

func (h *HubClient) handleCommand(data any) {
	dataBytes, err := json.Marshal(data)
	if err != nil {
		h.handler.OnError(fmt.Errorf("marshal command data: %w", err))
		return
	}

	var cmd CommandData
	if err := json.Unmarshal(dataBytes, &cmd); err != nil {
		h.handler.OnError(fmt.Errorf("unmarshal command: %w", err))
		return
	}

	h.handler.OnCommand(&cmd)
}

func (h *HubClient) handleConfigSync(data any) {
	dataBytes, err := json.Marshal(data)
	if err != nil {
		h.handler.OnError(fmt.Errorf("marshal config sync data: %w", err))
		return
	}

	var sync ConfigSyncData
	if err := json.Unmarshal(dataBytes, &sync); err != nil {
		h.handler.OnError(fmt.Errorf("unmarshal config sync: %w", err))
		return
	}

	h.handler.OnConfigSync(&sync)
}

func (h *HubClient) handleSubscriptionSync(data any) {
	dataBytes, err := json.Marshal(data)
	if err != nil {
		h.handler.OnError(fmt.Errorf("marshal subscription sync data: %w", err))
		return
	}

	var sync SubscriptionSyncData
	if err := json.Unmarshal(dataBytes, &sync); err != nil {
		h.handler.OnError(fmt.Errorf("unmarshal subscription sync: %w", err))
		return
	}

	h.handler.OnSubscriptionSync(&sync)
}

// ParseAPIURLChangedPayload parses the API URL changed payload from CommandData.
// Returns nil if the payload cannot be parsed.
//
// Usage in HubHandler.OnCommand:
//
//	func (h *MyHandler) OnCommand(cmd *agent.CommandData) {
//	    switch cmd.Action {
//	    case agent.CmdActionAPIURLChanged:
//	        payload := agent.ParseAPIURLChangedPayload(cmd.Payload)
//	        if payload != nil {
//	            // Update local configuration with payload.NewURL
//	            // Then close connection and reconnect with new URL
//	        }
//	    }
//	}
func ParseAPIURLChangedPayload(payload any) *APIURLChangedPayload {
	if payload == nil {
		return nil
	}

	dataBytes, err := json.Marshal(payload)
	if err != nil {
		return nil
	}

	var p APIURLChangedPayload
	if err := json.Unmarshal(dataBytes, &p); err != nil {
		return nil
	}

	return &p
}
