#!/bin/bash

# Orrisp Node Agent Installer
# Usage:
#   Install:   sudo bash install.sh --api-url https://api.example.com --node node_xxx:token [--node node_yyy:token] [--version latest]
#   Uninstall: sudo bash install.sh uninstall

set -e

# Configuration
BINARY_NAME="orrisp"
SERVICE_NAME="orrisp"
INSTALL_DIR="/usr/local/bin"
CONFIG_DIR="/etc/orrisp"
CONFIG_FILE="${CONFIG_DIR}/config.yaml"
CERT_DIR="/var/lib/orrisp/certs"
GITHUB_REPO="orris-inc/orrisp"
DOWNLOAD_TIMEOUT=120
CONNECT_TIMEOUT=10
MAX_RETRIES=3

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Print functions
print_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if running as root
check_root() {
    if [ "$(id -u)" != "0" ]; then
        print_error "This script must be run as root"
        exit 1
    fi
}

# Detect platform
detect_platform() {
    local os=$(uname -s | tr '[:upper:]' '[:lower:]')
    local arch=$(uname -m)

    case "$os" in
        linux|darwin)
            ;;
        *)
            print_error "Unsupported operating system: $os. Only Linux and macOS are supported."
            exit 1
            ;;
    esac

    case "$arch" in
        x86_64|amd64)
            PLATFORM="${os}-amd64"
            ;;
        aarch64|arm64)
            PLATFORM="${os}-arm64"
            ;;
        *)
            print_error "Unsupported architecture: $arch. Only amd64 and arm64 are supported."
            exit 1
            ;;
    esac

    print_info "Detected platform: $PLATFORM"
}

# Get latest version from GitHub releases
get_latest_version() {
    local latest_url="https://api.github.com/repos/${GITHUB_REPO}/releases/latest"
    local version

    version=$(curl -sf --connect-timeout ${CONNECT_TIMEOUT} "$latest_url" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')

    if [ -z "$version" ]; then
        print_error "Failed to fetch latest version from GitHub"
        exit 1
    fi

    echo "$version"
}

# Download binary with retry
download_binary() {
    local version="$1"
    local binary_name="${BINARY_NAME}-${PLATFORM}"
    local download_url="https://github.com/${GITHUB_REPO}/releases/download/${version}/${binary_name}"
    local temp_file="/tmp/${binary_name}"

    print_info "Downloading ${BINARY_NAME} ${version} for ${PLATFORM}..."

    local attempt=0
    while [ $attempt -lt $MAX_RETRIES ]; do
        attempt=$((attempt + 1))
        print_info "Download attempt $attempt of $MAX_RETRIES..."

        if curl -fL --connect-timeout ${CONNECT_TIMEOUT} --max-time ${DOWNLOAD_TIMEOUT} \
            -o "$temp_file" "$download_url"; then
            chmod +x "$temp_file"
            mv "$temp_file" "${INSTALL_DIR}/${BINARY_NAME}"
            print_info "Binary downloaded successfully"
            return 0
        fi

        print_warn "Download attempt $attempt failed"
        rm -f "$temp_file"
        sleep 2
    done

    print_error "Failed to download binary after $MAX_RETRIES attempts"
    exit 1
}

# Create configuration file
create_config() {
    local api_url="$1"
    shift
    local nodes=("$@")

    print_info "Creating configuration directory..."
    mkdir -p "$CONFIG_DIR"

    print_info "Creating configuration file..."
    cat > "$CONFIG_FILE" << EOF
# Orrisp Node Agent Configuration
# Generated by install.sh

# API configuration
api:
  base_url: "${api_url}"
  timeout: 30

# Node configuration
nodes:
EOF

    for node in "${nodes[@]}"; do
        local sid=$(echo "$node" | cut -d':' -f1)
        local token=$(echo "$node" | cut -d':' -f2-)
        cat >> "$CONFIG_FILE" << EOF
  - sid: "${sid}"
    token: "${token}"
    cert_path: ""
    key_path: ""
EOF
    done

    cat >> "$CONFIG_FILE" << EOF

# Sync configuration
sync:
  user_interval: 60
  traffic_interval: 60
  status_interval: 30
  online_interval: 10

# Log configuration
log:
  level: "info"
  output: "stdout"
EOF

    # Set restrictive permissions
    chmod 600 "$CONFIG_FILE"
    print_info "Configuration file created at $CONFIG_FILE"
}

# Setup certificate directory
setup_cert_directory() {
    print_info "Setting up certificate directory..."

    # Create certificate directory with proper permissions
    if mkdir -p "$CERT_DIR" 2>/dev/null; then
        chmod 700 "$CERT_DIR"
        print_info "Certificate directory created at $CERT_DIR"
        print_info "Certificates will be persisted across restarts"
    else
        print_warn "Failed to create persistent certificate directory at $CERT_DIR"
        print_warn "Certificates will be stored in /tmp (not persistent across reboots)"
        print_warn "This is normal if /var/lib is read-only. Service will use fallback directory."
    fi
}

# Create systemd service
create_service() {
    print_info "Creating systemd service..."

    cat > "/etc/systemd/system/${SERVICE_NAME}.service" << EOF
[Unit]
Description=Orrisp Node Agent
After=network.target

[Service]
Type=simple
ExecStart=${INSTALL_DIR}/${BINARY_NAME} -c ${CONFIG_FILE}
Restart=always
RestartSec=5
StartLimitInterval=60
StartLimitBurst=3

# Security hardening
NoNewPrivileges=true
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
ReadWritePaths=${CONFIG_DIR} ${CERT_DIR}

[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload
    print_info "Systemd service created"
}

# Start service
start_service() {
    print_info "Enabling and starting service..."
    systemctl enable "${SERVICE_NAME}" >/dev/null 2>&1
    systemctl start "${SERVICE_NAME}"
    print_info "Service started successfully"
}

# Stop service
stop_service() {
    if systemctl is-active --quiet "${SERVICE_NAME}" 2>/dev/null; then
        print_info "Stopping service..."
        systemctl stop "${SERVICE_NAME}" || true
    fi
}

# Install function
install() {
    local api_url=""
    local version="latest"
    local nodes=()

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --api-url)
                api_url="$2"
                shift 2
                ;;
            --node)
                nodes+=("$2")
                shift 2
                ;;
            --version)
                version="$2"
                shift 2
                ;;
            *)
                print_error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done

    # Validate required parameters
    if [ -z "$api_url" ]; then
        print_error "Missing required parameter: --api-url"
        usage
        exit 1
    fi

    if [ ${#nodes[@]} -eq 0 ]; then
        print_error "Missing required parameter: --node"
        usage
        exit 1
    fi

    # Validate node format (supports numeric IDs and Stripe-style IDs like node_xxx)
    for node in "${nodes[@]}"; do
        if ! echo "$node" | grep -qE '^[a-zA-Z0-9_]+:.+$'; then
            print_error "Invalid node format: $node (expected id:token)"
            exit 1
        fi
    done

    print_info "Starting Orrisp Node Agent installation..."

    # Detect platform
    detect_platform

    # Stop existing service if running
    stop_service

    # Backup existing binary if present
    if [ -f "${INSTALL_DIR}/${BINARY_NAME}" ]; then
        print_info "Backing up existing binary..."
        mv "${INSTALL_DIR}/${BINARY_NAME}" "${INSTALL_DIR}/${BINARY_NAME}.bak"
    fi

    # Get version
    if [ "$version" = "latest" ]; then
        version=$(get_latest_version)
    fi

    # Download binary
    if ! download_binary "$version"; then
        # Restore backup on failure
        if [ -f "${INSTALL_DIR}/${BINARY_NAME}.bak" ]; then
            print_warn "Restoring backup binary..."
            mv "${INSTALL_DIR}/${BINARY_NAME}.bak" "${INSTALL_DIR}/${BINARY_NAME}"
        fi
        exit 1
    fi

    # Remove backup
    rm -f "${INSTALL_DIR}/${BINARY_NAME}.bak"

    # Create configuration
    create_config "$api_url" "${nodes[@]}"

    # Setup certificate directory
    setup_cert_directory

    # Create and start service
    create_service
    start_service

    print_info "Installation completed successfully!"
    echo ""
    echo "Useful commands:"
    echo "  Check status:  systemctl status ${SERVICE_NAME}"
    echo "  View logs:     journalctl -u ${SERVICE_NAME} -f"
    echo "  Restart:       systemctl restart ${SERVICE_NAME}"
    echo "  Stop:          systemctl stop ${SERVICE_NAME}"
    echo "  Edit config:   nano ${CONFIG_FILE}"
    echo ""
    echo "Certificate storage:"
    if [ -d "$CERT_DIR" ] && [ -w "$CERT_DIR" ]; then
        echo "  Persistent:    $CERT_DIR (certificates persist across reboots)"
    else
        echo "  Temporary:     /tmp/orrisp/certs (certificates regenerated on reboot)"
    fi
}

# Uninstall function
uninstall() {
    print_info "Starting Orrisp Node Agent uninstallation..."

    # Stop and disable service
    if systemctl is-active --quiet "${SERVICE_NAME}" 2>/dev/null; then
        print_info "Stopping service..."
        systemctl stop "${SERVICE_NAME}" || true
    fi

    if systemctl is-enabled --quiet "${SERVICE_NAME}" 2>/dev/null; then
        print_info "Disabling service..."
        systemctl disable "${SERVICE_NAME}" || true
    fi

    # Remove service file
    if [ -f "/etc/systemd/system/${SERVICE_NAME}.service" ]; then
        print_info "Removing service file..."
        rm -f "/etc/systemd/system/${SERVICE_NAME}.service"
        systemctl daemon-reload
    fi

    # Remove binary
    if [ -f "${INSTALL_DIR}/${BINARY_NAME}" ]; then
        print_info "Removing binary..."
        rm -f "${INSTALL_DIR}/${BINARY_NAME}"
    fi
    rm -f "${INSTALL_DIR}/${BINARY_NAME}.bak"

    # Remove configuration
    if [ -d "$CONFIG_DIR" ]; then
        print_info "Removing configuration directory..."
        rm -rf "$CONFIG_DIR"
    fi

    # Remove certificate directory
    if [ -d "$CERT_DIR" ]; then
        print_info "Removing certificate directory..."
        rm -rf "$CERT_DIR"
    fi

    print_info "Uninstallation completed successfully!"
}

# Usage help
usage() {
    echo "Orrisp Node Agent Installer"
    echo ""
    echo "Usage:"
    echo "  Install:"
    echo "    sudo bash $0 --api-url <url> --node <id:token> [--node <id:token>] [--version <version>]"
    echo ""
    echo "  Uninstall:"
    echo "    sudo bash $0 uninstall"
    echo ""
    echo "Options:"
    echo "  --api-url <url>      API server URL (required)"
    echo "  --node <id:token>    Node ID and token in format 'id:token' (required, can be specified multiple times)"
    echo "  --version <version>  Version to install (default: latest)"
    echo ""
    echo "Examples:"
    echo "  Single node:"
    echo "    sudo bash $0 --api-url https://api.example.com --node node_abc123:your_token_here"
    echo ""
    echo "  Multiple nodes:"
    echo "    sudo bash $0 --api-url https://api.example.com --node node_abc:token1 --node node_def:token2"
    echo ""
    echo "  Specific version:"
    echo "    sudo bash $0 --api-url https://api.example.com --node node_abc:token --version v1.0.0"
}

# Main
main() {
    if [ $# -eq 0 ]; then
        usage
        exit 1
    fi

    check_root

    case "$1" in
        uninstall)
            uninstall
            ;;
        --help|-h)
            usage
            ;;
        *)
            install "$@"
            ;;
    esac
}

main "$@"
