#!/bin/bash

# Orrisp Node Agent Installer
# Usage:
#   Install:   sudo bash install.sh --api-url https://api.example.com --node node_xxx:token [--node node_yyy:token] [--version latest]
#   Uninstall: sudo bash install.sh uninstall

set -e

# Configuration
BINARY_NAME="orrisp"
SERVICE_NAME="orrisp"
INSTALL_DIR="/usr/local/bin"
CONFIG_DIR="/etc/orrisp"
CONFIG_FILE="${CONFIG_DIR}/config.yaml"
CERT_DIR="/var/lib/orrisp/certs"
LOG_FILE="/var/log/orrisp.log"
GITHUB_REPO="orris-inc/orrisp"
DOWNLOAD_TIMEOUT=120
CONNECT_TIMEOUT=10
MAX_RETRIES=3
INIT_SYSTEM=""

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Print functions
print_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if running as root
check_root() {
    if [ "$(id -u)" != "0" ]; then
        print_error "This script must be run as root"
        exit 1
    fi
}

# Detect platform
detect_platform() {
    local os=$(uname -s | tr '[:upper:]' '[:lower:]')
    local arch=$(uname -m)

    case "$os" in
        linux|darwin)
            ;;
        *)
            print_error "Unsupported operating system: $os. Only Linux and macOS are supported."
            exit 1
            ;;
    esac

    case "$arch" in
        x86_64|amd64)
            PLATFORM="${os}-amd64"
            ;;
        aarch64|arm64)
            PLATFORM="${os}-arm64"
            ;;
        *)
            print_error "Unsupported architecture: $arch. Only amd64 and arm64 are supported."
            exit 1
            ;;
    esac

    print_info "Detected platform: $PLATFORM"
}

# Detect init system (systemd or openrc)
detect_init_system() {
    if command -v systemctl >/dev/null 2>&1 && [ -d /run/systemd/system ]; then
        INIT_SYSTEM="systemd"
    elif command -v rc-service >/dev/null 2>&1; then
        INIT_SYSTEM="openrc"
    else
        print_error "Unsupported init system. Only systemd and OpenRC are supported."
        exit 1
    fi
    print_info "Detected init system: $INIT_SYSTEM"
}

# Get latest version from GitHub releases
get_latest_version() {
    local latest_url="https://api.github.com/repos/${GITHUB_REPO}/releases/latest"
    local version

    version=$(curl -sf --connect-timeout ${CONNECT_TIMEOUT} "$latest_url" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')

    if [ -z "$version" ]; then
        print_error "Failed to fetch latest version from GitHub"
        exit 1
    fi

    echo "$version"
}

# Download binary with retry
download_binary() {
    local version="$1"
    local binary_name="${BINARY_NAME}-${PLATFORM}"
    local download_url="https://github.com/${GITHUB_REPO}/releases/download/${version}/${binary_name}"
    local temp_file="/tmp/${binary_name}"

    print_info "Downloading ${BINARY_NAME} ${version} for ${PLATFORM}..."

    local attempt=0
    while [ $attempt -lt $MAX_RETRIES ]; do
        attempt=$((attempt + 1))
        print_info "Download attempt $attempt of $MAX_RETRIES..."

        if curl -fL --connect-timeout ${CONNECT_TIMEOUT} --max-time ${DOWNLOAD_TIMEOUT} \
            -o "$temp_file" "$download_url"; then
            chmod +x "$temp_file"
            mv "$temp_file" "${INSTALL_DIR}/${BINARY_NAME}"
            print_info "Binary downloaded successfully"
            return 0
        fi

        print_warn "Download attempt $attempt failed"
        rm -f "$temp_file"
        sleep 2
    done

    print_error "Failed to download binary after $MAX_RETRIES attempts"
    exit 1
}

# Create configuration file
create_config() {
    local api_url="$1"
    shift
    local nodes=("$@")

    print_info "Creating configuration directory..."
    mkdir -p "$CONFIG_DIR"

    print_info "Creating configuration file..."
    cat > "$CONFIG_FILE" << EOF
# Orrisp Node Agent Configuration
# Generated by install.sh

# API configuration
api:
  base_url: "${api_url}"
  timeout: 30

# Node configuration
nodes:
EOF

    for node in "${nodes[@]}"; do
        local sid=$(echo "$node" | cut -d':' -f1)
        local token=$(echo "$node" | cut -d':' -f2-)
        cat >> "$CONFIG_FILE" << EOF
  - sid: "${sid}"
    token: "${token}"
    cert_path: ""
    key_path: ""
EOF
    done

    cat >> "$CONFIG_FILE" << EOF

# Sync configuration
sync:
  user_interval: 60
  traffic_interval: 60
  status_interval: 30
  online_interval: 10

# Log configuration
log:
  level: "info"
  output: "stdout"
EOF

    # Set restrictive permissions
    chmod 600 "$CONFIG_FILE"
    print_info "Configuration file created at $CONFIG_FILE"
}

# Setup certificate directory
setup_cert_directory() {
    print_info "Setting up certificate directory..."

    # Create certificate directory with proper permissions
    if mkdir -p "$CERT_DIR" 2>/dev/null; then
        chmod 700 "$CERT_DIR"
        print_info "Certificate directory created at $CERT_DIR"
        print_info "Certificates will be persisted across restarts"
    else
        print_warn "Failed to create persistent certificate directory at $CERT_DIR"
        print_warn "Certificates will be stored in /tmp (not persistent across reboots)"
        print_warn "This is normal if /var/lib is read-only. Service will use fallback directory."
    fi
}

# Check if mount namespaces are supported (not available in some containers)
check_namespace_support() {
    # Check if we are in a container that lacks namespace support
    if command -v systemd-detect-virt >/dev/null 2>&1; then
        local virt_type
        virt_type=$(systemd-detect-virt --container 2>/dev/null || true)
        case "$virt_type" in
            openvz|lxc|lxc-libvirt)
                return 1
                ;;
        esac
    fi

    # Test if unshare works (direct namespace support check)
    if unshare --mount true 2>/dev/null; then
        return 0
    fi

    return 1
}

# Create systemd service file
create_systemd_service() {
    print_info "Creating systemd service..."

    local security_opts=""
    if check_namespace_support; then
        security_opts="# Security hardening
NoNewPrivileges=true
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
ReadWritePaths=${CONFIG_DIR} ${CERT_DIR} ${INSTALL_DIR}"
        print_info "Namespace support detected, enabling security hardening"
    else
        security_opts="# Security hardening (limited: mount namespaces not available)
NoNewPrivileges=true"
        print_warn "Mount namespaces not supported, skipping ProtectSystem/ProtectHome/PrivateTmp"
    fi

    cat > "/etc/systemd/system/${SERVICE_NAME}.service" << EOF
[Unit]
Description=Orrisp Node Agent
After=network.target

[Service]
Type=simple
ExecStart=${INSTALL_DIR}/${BINARY_NAME} -c ${CONFIG_FILE}
Restart=always
RestartSec=5
StartLimitInterval=60
StartLimitBurst=3

${security_opts}

[Install]
WantedBy=multi-user.target
EOF

    systemctl daemon-reload
    print_info "Systemd service created"
}

# Create OpenRC service file
create_openrc_service() {
    print_info "Creating OpenRC service..."

    cat > "/etc/init.d/${SERVICE_NAME}" << 'INITEOF'
#!/sbin/openrc-run
# Orrisp Node Agent OpenRC init script

name="orrisp"
description="Orrisp Node Agent"
command="/usr/local/bin/orrisp"
command_args="-c /etc/orrisp/config.yaml"
command_background="yes"
pidfile="/run/${RC_SVCNAME}.pid"
output_log="/var/log/orrisp.log"
error_log="/var/log/orrisp.log"

depend() {
    need net
    after firewall
}

start_pre() {
    checkpath --file --mode 0644 "$output_log"
}
INITEOF

    chmod +x "/etc/init.d/${SERVICE_NAME}"
    print_info "OpenRC service created"
}

# Create service (dispatcher)
create_service() {
    case "$INIT_SYSTEM" in
        systemd)
            create_systemd_service
            ;;
        openrc)
            create_openrc_service
            ;;
    esac
}

# Start service
start_service() {
    print_info "Enabling and starting service..."
    case "$INIT_SYSTEM" in
        systemd)
            systemctl enable "${SERVICE_NAME}" >/dev/null 2>&1
            systemctl start "${SERVICE_NAME}"
            ;;
        openrc)
            rc-update add "${SERVICE_NAME}" default >/dev/null 2>&1
            rc-service "${SERVICE_NAME}" start
            ;;
    esac
    print_info "Service started successfully"
}

# Stop service
stop_service() {
    case "$INIT_SYSTEM" in
        systemd)
            if systemctl is-active --quiet "${SERVICE_NAME}" 2>/dev/null; then
                print_info "Stopping service..."
                systemctl stop "${SERVICE_NAME}" || true
            fi
            ;;
        openrc)
            if rc-service "${SERVICE_NAME}" status >/dev/null 2>&1; then
                print_info "Stopping service..."
                rc-service "${SERVICE_NAME}" stop || true
            fi
            ;;
    esac
}

# Install function
install() {
    local api_url=""
    local version="latest"
    local nodes=()

    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            --api-url)
                api_url="$2"
                shift 2
                ;;
            --node)
                nodes+=("$2")
                shift 2
                ;;
            --version)
                version="$2"
                shift 2
                ;;
            *)
                print_error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done

    # Validate required parameters
    if [ -z "$api_url" ]; then
        print_error "Missing required parameter: --api-url"
        usage
        exit 1
    fi

    if [ ${#nodes[@]} -eq 0 ]; then
        print_error "Missing required parameter: --node"
        usage
        exit 1
    fi

    # Validate node format (supports numeric IDs and Stripe-style IDs like node_xxx)
    for node in "${nodes[@]}"; do
        if ! echo "$node" | grep -qE '^[a-zA-Z0-9_]+:.+$'; then
            print_error "Invalid node format: $node (expected id:token)"
            exit 1
        fi
    done

    print_info "Starting Orrisp Node Agent installation..."

    # Detect platform and init system
    detect_platform
    detect_init_system

    # Stop existing service if running
    stop_service

    # Backup existing binary if present
    if [ -f "${INSTALL_DIR}/${BINARY_NAME}" ]; then
        print_info "Backing up existing binary..."
        mv "${INSTALL_DIR}/${BINARY_NAME}" "${INSTALL_DIR}/${BINARY_NAME}.bak"
    fi

    # Get version
    if [ "$version" = "latest" ]; then
        version=$(get_latest_version)
    fi

    # Download binary
    if ! download_binary "$version"; then
        # Restore backup on failure
        if [ -f "${INSTALL_DIR}/${BINARY_NAME}.bak" ]; then
            print_warn "Restoring backup binary..."
            mv "${INSTALL_DIR}/${BINARY_NAME}.bak" "${INSTALL_DIR}/${BINARY_NAME}"
        fi
        exit 1
    fi

    # Remove backup
    rm -f "${INSTALL_DIR}/${BINARY_NAME}.bak"

    # Create configuration
    create_config "$api_url" "${nodes[@]}"

    # Setup certificate directory
    setup_cert_directory

    # Create and start service
    create_service
    start_service

    print_info "Installation completed successfully!"
    echo ""
    echo "Useful commands:"
    case "$INIT_SYSTEM" in
        systemd)
            echo "  Check status:  systemctl status ${SERVICE_NAME}"
            echo "  View logs:     journalctl -u ${SERVICE_NAME} -f"
            echo "  Restart:       systemctl restart ${SERVICE_NAME}"
            echo "  Stop:          systemctl stop ${SERVICE_NAME}"
            ;;
        openrc)
            echo "  Check status:  rc-service ${SERVICE_NAME} status"
            echo "  View logs:     tail -f ${LOG_FILE}"
            echo "  Restart:       rc-service ${SERVICE_NAME} restart"
            echo "  Stop:          rc-service ${SERVICE_NAME} stop"
            ;;
    esac
    echo "  Edit config:   nano ${CONFIG_FILE}"
    echo ""
    echo "Certificate storage:"
    if [ -d "$CERT_DIR" ] && [ -w "$CERT_DIR" ]; then
        echo "  Persistent:    $CERT_DIR (certificates persist across reboots)"
    else
        echo "  Temporary:     /tmp/orrisp/certs (certificates regenerated on reboot)"
    fi
}

# Kill process by name with timeout
kill_process() {
    local pids
    pids=$(pgrep -x "${BINARY_NAME}" 2>/dev/null || true)

    if [ -z "$pids" ]; then
        return 0
    fi

    print_info "Sending SIGTERM to ${BINARY_NAME} processes..."
    pkill -x "${BINARY_NAME}" 2>/dev/null || true

    # Wait for graceful shutdown (max 10 seconds)
    local count=0
    while [ $count -lt 10 ]; do
        if ! pgrep -x "${BINARY_NAME}" >/dev/null 2>&1; then
            print_info "Process terminated gracefully"
            return 0
        fi
        sleep 1
        count=$((count + 1))
    done

    # Force kill if still running
    if pgrep -x "${BINARY_NAME}" >/dev/null 2>&1; then
        print_warn "Process did not terminate gracefully, sending SIGKILL..."
        pkill -9 -x "${BINARY_NAME}" 2>/dev/null || true
        sleep 1
    fi

    # Final check
    if pgrep -x "${BINARY_NAME}" >/dev/null 2>&1; then
        print_error "Failed to kill ${BINARY_NAME} process"
        return 1
    fi

    print_info "Process terminated"
    return 0
}

# Uninstall function
uninstall() {
    print_info "Starting Orrisp Node Agent uninstallation..."

    # Detect init system for proper cleanup
    detect_init_system

    # Stop and disable service based on init system
    case "$INIT_SYSTEM" in
        systemd)
            if systemctl is-active --quiet "${SERVICE_NAME}" 2>/dev/null; then
                print_info "Stopping service..."
                systemctl stop "${SERVICE_NAME}" || true
                sleep 2
            fi

            if systemctl is-enabled --quiet "${SERVICE_NAME}" 2>/dev/null; then
                print_info "Disabling service..."
                systemctl disable "${SERVICE_NAME}" || true
            fi
            ;;
        openrc)
            if rc-service "${SERVICE_NAME}" status >/dev/null 2>&1; then
                print_info "Stopping service..."
                rc-service "${SERVICE_NAME}" stop || true
                sleep 2
            fi

            if rc-update show default 2>/dev/null | grep -q "${SERVICE_NAME}"; then
                print_info "Disabling service..."
                rc-update del "${SERVICE_NAME}" default || true
            fi
            ;;
    esac

    # Ensure process is killed (handles non-service starts)
    kill_process

    # Remove service file based on init system
    case "$INIT_SYSTEM" in
        systemd)
            if [ -f "/etc/systemd/system/${SERVICE_NAME}.service" ]; then
                print_info "Removing service file..."
                rm -f "/etc/systemd/system/${SERVICE_NAME}.service"
                systemctl daemon-reload
            fi
            ;;
        openrc)
            if [ -f "/etc/init.d/${SERVICE_NAME}" ]; then
                print_info "Removing service file..."
                rm -f "/etc/init.d/${SERVICE_NAME}"
            fi
            ;;
    esac

    # Remove binary
    if [ -f "${INSTALL_DIR}/${BINARY_NAME}" ]; then
        print_info "Removing binary..."
        rm -f "${INSTALL_DIR}/${BINARY_NAME}"
    fi
    rm -f "${INSTALL_DIR}/${BINARY_NAME}.bak"

    # Remove configuration
    if [ -d "$CONFIG_DIR" ]; then
        print_info "Removing configuration directory..."
        rm -rf "$CONFIG_DIR"
    fi

    # Remove certificate directory
    if [ -d "$CERT_DIR" ]; then
        print_info "Removing certificate directory..."
        rm -rf "$CERT_DIR"
    fi

    # Remove parent directory if empty
    if [ -d "/var/lib/orrisp" ]; then
        rmdir "/var/lib/orrisp" 2>/dev/null || true
    fi

    # Remove temp certificate directory
    if [ -d "/tmp/orrisp" ]; then
        print_info "Removing temp directory..."
        rm -rf "/tmp/orrisp"
    fi

    # Remove log file (OpenRC)
    if [ -f "$LOG_FILE" ]; then
        print_info "Removing log file..."
        rm -f "$LOG_FILE"
    fi

    print_info "Uninstallation completed successfully!"
}

# Usage help
usage() {
    echo "Orrisp Node Agent Installer"
    echo ""
    echo "Usage:"
    echo "  Install:"
    echo "    sudo bash $0 --api-url <url> --node <id:token> [--node <id:token>] [--version <version>]"
    echo ""
    echo "  Uninstall:"
    echo "    sudo bash $0 uninstall"
    echo ""
    echo "Options:"
    echo "  --api-url <url>      API server URL (required)"
    echo "  --node <id:token>    Node ID and token in format 'id:token' (required, can be specified multiple times)"
    echo "  --version <version>  Version to install (default: latest)"
    echo ""
    echo "Examples:"
    echo "  Single node:"
    echo "    sudo bash $0 --api-url https://api.example.com --node node_abc123:your_token_here"
    echo ""
    echo "  Multiple nodes:"
    echo "    sudo bash $0 --api-url https://api.example.com --node node_abc:token1 --node node_def:token2"
    echo ""
    echo "  Specific version:"
    echo "    sudo bash $0 --api-url https://api.example.com --node node_abc:token --version v1.0.0"
}

# Main
main() {
    if [ $# -eq 0 ]; then
        usage
        exit 1
    fi

    check_root

    case "$1" in
        uninstall)
            uninstall
            ;;
        --help|-h)
            usage
            ;;
        *)
            install "$@"
            ;;
    esac
}

main "$@"
